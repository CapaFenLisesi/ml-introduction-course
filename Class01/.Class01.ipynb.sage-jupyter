{"kernelspec":{"display_name":"Python 2 (SageMath)","language":"python","name":"python2"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}}
{"cell_type":"markdown","metadata":{},"source":"# Class 01\n## Big Data Ingesting: CSVs, Data frames, and Plots\n\nWelcome to PHY178/CSC171. We will be using the Python language to import data, run machine learning, visualize the results, and communicate those results.\n\nMuch of the data that we will use this semester is stored in a `CSV` file. This stand for `Comma-separated Values`. The data files are stored in rows- one row per line, with the column values separated by commas. Take a quick look at the data in `Class01_diabetes_data.csv` by clicking on it in the \"Files\" tab. You can see that the entries all bunch up together since they are separated by the comma delimeter, not by space.\n\n### Where to get data\nWe will spend quite a bit of time looking for public data as we get going in this class. Here are a couple of places to look for data sets to work with:\n* The UCI repository: https://archive.ics.uci.edu/ml/datasets.html\n* Kaggle Public Datasets: https://www.kaggle.com/datasets\n* Ceasar's repository: https://github.com/caesar0301/awesome-public-datasets\n\nExplore a few of these and try downloading one of the files. For example, the data in the UCI repository can be downloaded from the \"Data Folder\" links. You have to right-click the file, then save it to the local computer. Their files aren't labeled as \"CSV\" files (the file extension is .data), but they are CSV files.\n\n### How to put it on the cloud\n\nOnce you have a data file, you need to upload it to the cloud so that we can import it and plot it. The easiest way to do this is to click on the \"Files\" link in the toolbar. Click on the \"Create\" button and then drag the file into the upload box. Put the file in the same folder as the Class01 notebook and you'll be able to load it later on.\n\n\n"}
{"cell_type":"markdown","metadata":{},"source":"## Import Regression Data\n\nThe first thing we want to do is to import data into our notebook so that we can examine it, evaluate it, and use machine learning to learn from it. We will be using a Python library that makes all of that much easier. \n\n_**Jupyter Hint: Run the command in the next window to import that Pandas library. You evaluate cells in the notebook by highlighting them (by clicking on them), then pressing Shift-Enter to execute the cell.**_"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"import pandas as pd"}
{"cell_type":"markdown","metadata":{},"source":"The next step will be to copy the data file that we will be using for this tutorial into the same folder as these notes. We will be looking at a couple of different types of data sets. We'll start with a simple data set that appears to be a functional set of data where one output column depends on the input columns of the data. In this case, we're looking at a set of patient data where there are a handful of input variables that may feed into the likelyhood that the patient will develop type 2 diabetes. The output column is a quantitative measure of disease progression one year after baseline measurements. (http://www4.stat.ncsu.edu/~boos/var.select/diabetes.html)"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"diabetes = pd.read_csv('Class01_diabetes_data.csv')"}
{"cell_type":"markdown","metadata":{},"source":"Now that we've loaded the data in, the first thing to do is to take a look at the raw data. We can look at the first 5 rows (the head of the data set) by doing the following."}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::536628b9-f232-4ec3-9c65-cc2c900dd7cc","text/plain":"smc-blob::8921bd4b-4cf5-49a8-a39c-5f9dd21b7054"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"diabetes.head()"}
{"cell_type":"markdown","metadata":{},"source":"Before we move forward, note that there is a strange value in the first row under 'GLU': `NaN`. This means 'not a number' and indicates there was a missing value or other problem with the data. Before we move foward, we want to drop any row that has missing values in it. There is a simple pandas command that will do that: `dropna(inplace=True)`. The argument to this command: `inplace=True` tells the computer to drop the rows in our current dataset, not make a new copy."}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::b11c9ba2-d5ab-4671-9927-4eecbce0047d","text/plain":"smc-blob::790327c3-eb72-40f9-98aa-6bae29b1cdc6"},"execution_count":4,"metadata":{},"output_type":"execute_result"}],"source":"diabetes.dropna(inplace=True)\ndiabetes.head()"}
{"cell_type":"markdown","metadata":{},"source":"So we see the first row is gone. That's what we wanted. However, this doesn't really tell us much by itself. It is better to start investigating how the output variable ('Target' in this case) depends on the inputs. We'll visualize the data one at a time to look at this. We'll make a scatter plot where we look at the Target as a function of the Age column. The first entry provides the 'x' values where the second provides the 'y' values. The final input tells the plotting software to plot the data points as dots, not connected lines. We'll almost always use this feature."}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f1f929601d0>"},"execution_count":5,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::99ebe565-da5d-44ef-aa8c-b9226a52c9d8","text/plain":"<matplotlib.figure.Figure at 0x7f1f92960e10>"},"metadata":{},"output_type":"display_data"}],"source":"diabetes.plot(x='Age',y='Target',kind='scatter')"}
{"cell_type":"markdown","metadata":{},"source":"This doesn't tell us much. It looks like there isn't a large dependence on age - othewise we would have seen something more specific than a large blob of data. Let's try other inputs. We'll plot a bunch of them in a row.\n\n_**Jupyter Hint: Clicking in the white space next to the output cell will expand and contract the output contents. This is helpful when you have lots of output. **_"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f1f90284e90>"},"execution_count":6,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::10fdca58-1358-44ea-99b2-fec65b9fc336","text/plain":"<matplotlib.figure.Figure at 0x7f1fa94a0150>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::208fd1e4-3491-4089-9fad-20837c6f4b4b","text/plain":"<matplotlib.figure.Figure at 0x7f1f92960f50>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::23f21614-1d36-4a06-9740-5980535967bc","text/plain":"<matplotlib.figure.Figure at 0x7f1f907f2fd0>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::040b348e-49b7-432a-b98a-e1c594ee23b8","text/plain":"<matplotlib.figure.Figure at 0x7f1f907b0550>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::40e4ea8a-9e70-41dd-8bc8-ad10bbaa77da","text/plain":"<matplotlib.figure.Figure at 0x7f1f9058db50>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::b230ede0-c35c-413f-bff8-0c1754ee5801","text/plain":"<matplotlib.figure.Figure at 0x7f1f904aa3d0>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::77ebe2e3-85bd-4328-815a-519850c5cabc","text/plain":"<matplotlib.figure.Figure at 0x7f1f903eccd0>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::aceb405f-acc0-4823-aaf0-9a5621f8f7a6","text/plain":"<matplotlib.figure.Figure at 0x7f1f90387490>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::86340a01-13f5-4f0f-bf30-bb01652f34cb","text/plain":"<matplotlib.figure.Figure at 0x7f1f90258e10>"},"metadata":{},"output_type":"display_data"}],"source":"diabetes.plot(x='Sex',y='Target',kind='scatter')\ndiabetes.plot(x='BMI',y='Target',kind='scatter')\ndiabetes.plot(x='BP',y='Target',kind='scatter')\ndiabetes.plot(x='TC',y='Target',kind='scatter')\ndiabetes.plot(x='LDL',y='Target',kind='scatter')\ndiabetes.plot(x='HDL',y='Target',kind='scatter')\ndiabetes.plot(x='TCH',y='Target',kind='scatter')\ndiabetes.plot(x='LTG',y='Target',kind='scatter')\ndiabetes.plot(x='GLU',y='Target',kind='scatter')"}
{"cell_type":"markdown","metadata":{},"source":"It looks like there are some of these, like BMI, that as the BMI goes up, so does the Target."}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"# Import Classification Data\n\nThere is another type of data set where we have any number of input variables, but the output is no longer a continuous number, but rather it is a _class_. By that we mean that it is one of a finite number of possibilities. For example, in this next data set, we are looking at the characteristics of three different iris flowers. The measurements apply to one of the three types:\n* Setosa\n* Versicolour\n* Virginica\n\nLet's take a look at this data set and see what it takes to visualize it. First load the data in and inspect the first few rows."}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::bb5ebec9-9fbb-4cf6-af80-ec68f691e830","text/plain":"smc-blob::64761347-d478-4dbd-9331-58a7f0feacbd"},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":"irisDF = pd.read_csv('Class01_iris_data.csv')\n\nirisDF.head()"}
{"cell_type":"markdown","metadata":{},"source":"As you can see, the 'target' column is no longer numerical, but a text entry that is one of the three possible iris varieties. We also see that the default column headings are a bit long and will get tiring to type out when we want to reference them. Let's rename the columns first."}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::5fc13192-659c-40ff-ac90-e23210d2b893","text/plain":"   sepalLen  sepalWid  petalLen  petalWid       target\n0       5.0       2.3       3.3       1.0  Versicolour\n1       5.7       2.9       4.2       1.3  Versicolour\n2       4.7       3.2       1.6       0.2       Setosa\n3       7.7       3.0       6.1       2.3    Virginica\n4       5.5       2.5       4.0       1.3  Versicolour"},"execution_count":8,"metadata":{},"output_type":"execute_result"}],"source":"irisDF.columns=['sepalLen','sepalWid','petalLen','petalWid','target']\n\nirisDF.head()"}
{"cell_type":"markdown","metadata":{},"source":"Now we want to visualize the data. We don't know what to expect, so let's just pick a couple of variables and see what the data look like."}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f1f9004db10>"},"execution_count":9,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::2df9db77-41f2-436e-a387-a944f6972a8d","text/plain":"<matplotlib.figure.Figure at 0x7f1fa8eccf50>"},"metadata":{},"output_type":"display_data"}],"source":"irisDF.plot(x='sepalLen',y='sepalWid',kind='scatter')"}
{"cell_type":"markdown","metadata":{},"source":"So we see that there are entries at a number of different points, but it would be really nice to be able to identify which point correpsonds to which variety. We will use another python library to do this. We'll also set the default style to '`white`' which looks better."}
{"cell_type":"code","execution_count":10,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"import seaborn as sns\nsns.set_style('white')"}
{"cell_type":"markdown","metadata":{},"source":"The `seaborn` library provides a number of different plotting options. One of them is `lmplot`. It is designed to provide a linear model fit (which we don't want right now), so we'll set the `fig_reg` option to `False` so that it doesn't try to fit them. \n\nNote that we need two additional parameters here: the first is to tell `seaborn` to use the irisDF data. That means it will look in that data set for the x and y columns we provide. The second is the `hue` option. This tells `seaborn` what column to use to determine the color (or hue) of the points. In this case, it will notice that there are three different options in that column and color them appropriately."}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<seaborn.axisgrid.FacetGrid at 0x7f1f88618510>"},"execution_count":11,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::f7dc6645-5ab0-41b9-822f-358332fe9ac1","text/plain":"<matplotlib.figure.Figure at 0x7f1f886186d0>"},"metadata":{},"output_type":"display_data"}],"source":"sns.lmplot(x='sepalLen', y='sepalWid', data=irisDF, hue='target', fit_reg=False)"}
{"cell_type":"markdown","metadata":{},"source":"Now we can see that the cluster off to the left all belongs to the Setosa variety. It would be really nice to try plotting the other variables as well. We could do that manually or use a nice shortcut in `seaborn` called `pairplot`. This plots the `hue` column against all possible pairs of the other data columns."}
{"cell_type":"code","execution_count":12,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<seaborn.axisgrid.PairGrid at 0x7f1f903b1690>"},"execution_count":12,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::f99e362f-5afb-44ac-84f2-01ed33c25c48","text/plain":"<matplotlib.figure.Figure at 0x7f1f88888190>"},"metadata":{},"output_type":"display_data"}],"source":"sns.pairplot(irisDF, hue=\"target\")"}
{"cell_type":"markdown","metadata":{},"source":"We see that there are some of these plots that show there might be a way to distinuish the three different varieties. We'll look at how to do that later on, but this gives us a start."}
{"cell_type":"markdown","metadata":{},"source":"# Import Image Data\n\nThe last type of data we are going to look at are image data. This type of data provides information about each pixel (or element) in an image. We'll start by working with gray-scale images where each pixel could be a value anywhere between 0 (black) and 255 (white). We'll read in the data then look at how to create the image. This data set are handwritten digits from 0 to 9 that have been digitized. We will eventually try to teach the computer to read the handwritten digits."}
{"cell_type":"code","execution_count":13,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::a8afa6b9-c307-4566-b778-9073e4533480","text/plain":"smc-blob::7e938ab2-b77e-4db6-af50-cdd408851a9d"},"execution_count":13,"metadata":{},"output_type":"execute_result"}],"source":"digitDF = pd.read_csv('Class01_digits_data.csv')\n\ndigitDF.head()"}
{"cell_type":"markdown","metadata":{},"source":"This data set has 65 columns. The first 64 correspond to the grayscale value for each of the pixels in an 8 by 8 image. The last column (the 'target') indicates what digit the image is supposed to be. We'll pick one row to start with (row 41 in this case). We'll use some in-line commenting to explain each step here."}
{"cell_type":"code","execution_count":14,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Expected Digit: 3.0\n"},{"name":"stderr","output_type":"stream","text":"/projects/sage/sage-7.5/local/lib/python2.7/site-packages/ipykernel/__main__.py:10: FutureWarning: reshape is deprecated and will raise in a subsequent release. Please use .values.reshape(...) instead\n"},{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f1f87739d90>"},"execution_count":14,"metadata":{},"output_type":"execute_result"},{"data":{"text/plain":"<matplotlib.figure.Figure at 0x7f1f87afef50>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::7e31620f-7824-4d60-890d-1f03c9167aad","text/plain":"<matplotlib.figure.Figure at 0x7f1f9085a610>"},"metadata":{},"output_type":"display_data"}],"source":"testnum = 61\n#\n# First, get the first 64 columns which correspond to the image data\n#\ntestimage = digitDF.loc[testnum][0:64]\n\n#\n# Then reshape this from a 1 by 64 array into a matrix that is 8 by 8.\n#\ntestimage = testimage.reshape((8,8))\n\n#\n# We'll print out what the image is supposed to be. Note the format of the print statement. \n# The '{}' means 'insert the argument from the format here'. \n# The .format means 'pass these values into the string.\n#\nprint('Expected Digit: {}'.format(digitDF.loc[testnum][64]))\n\n#\n\n# Finally, we need one more library to plot the images.\n#\nimport matplotlib.pyplot as plt\n\n#\n# We tell Python to plot a gray scale image, then to show our resahped data as an image.\n#\nplt.gray() \nplt.matshow(testimage) "}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"# Practice\n\nThere is one more data set for you to practice on. It has the filename `Class01_breastcancer_data.csv`. This data set comes from a study of breast cancer in Wisconsin. You can read more about the data set on page 6 (search `BreastCancer`) of this file: https://cran.r-project.org/web/packages/mlbench/mlbench.pdf Go ahead and load the data, investigate what is there and plot the data to see what we have.\n\n"}
{"cell_type":"markdown","metadata":{},"source":"# Assignment\n\nYour assignment is to get your own data set loaded and plotted in your own notebook. This data exploration is the first step to doing machine learning. You will need to get at least 2 different data sets: one that will use a regression and one that is a classification set. We'll use them in future classes to explore different machine learning algorithms.\n\n## Working with SageMath Assignments\n\nYou have a copy of this file in your Assignments Folder. You should create a copy of this file and not modify it further. That way you won't accidentally erase any of the notes. Rename your file:\n> `Class01_to_grade.ipynb`\n\nThat way I will know what file to look at when I grade the assignments."}